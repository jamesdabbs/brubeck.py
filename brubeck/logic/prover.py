# Defines the native Prover class, the API to automatic proof generation
import logging

from django.contrib.auth.models import User
from django.utils.safestring import mark_safe

from brubeck.logic import Formula, utils
from brubeck.models.snippets import Snippet


logger = logging.getLogger(__name__)


BRUBECK_AGENT = utils.BRUBECK_AGENT


class BaseProver(object):
    """ The Prover class is the public interface to automatic proof generation.

        Every snippet added by a Prover *must* set proof_agent to a string that
        identifies the particular Prover used to add it, and allows that Prover
        to be re-imported and used to reason about that snippet.
    """
    def __init__(self, agent):
        """ Sets the Prover's agent string. This string should uniquely
            identify the Prover object by its import path, e.g.
            agent = 'brubeck.logic.prover.Prover'
        """
        self.agent = agent

    # Text / html rendering methods
    def _render(self, proof, html, space=True):
        """ Renders a proof string (as generated by this prover). If `html`
            is True, the output should include links to any other assumptions
            used in the proof. If not, the output should be plaintext.
        """
        from brubeck.models import Trait, Implication

        rv = ''
        for s in proof.split(',')[:-1]:
            type, id = s[0], s[1:]
            if type == 't':
                obj = Trait.objects.get(id=id)
                name = obj.__unicode__(space=space)
            else:  # type == 'i'
                obj = Implication.objects.get(id=id)
                name = obj.__unicode__(lookup=True)
            if html:
                rv += u'<a href="%s">%s</a><br/>' % (obj.get_absolute_url(),
                                                     name)
            else:
                rv += u'%s, ' % name
        # Trim a trailing comma / whitespace
        rv = rv.strip()
        if rv.endswith(u','):
            rv = rv[:-1].rstrip()
        return mark_safe(rv)

    def render_html(self, proof, space=True):
        """ Renders a proof string (as generated by this prover) into an
            html-formatted description of the proof.

            If `space`==False, the text may suppress mentions to the space,
            assuming it is understood from context.
        """
        return self._render(proof, html=True, space=space)

    def render_text(self, proof, space=True):
        """ Similar to render_html, but generates plain text.

            This text should be suitable for caching in snippet.proof_text
        """
        return self._render(proof, html=False, space=space)

    def get_full_proof(self, obj):
        """ Returns a structure describing an entire proof of this object
            (from manually added assumptions), in a format that can be passed
            as JSON and rendered on the proof explorer view. Right now, that
            format is a list of nodes, each of which is a dict:
            {
                'id': _,    # Used for the css id of the node
                'name': _,  # Used for the label on the node
                'data': _,  # The data to display in the sidebar for this node
                'adjacencies': _, # A list of nodes this is adjacent to
            }
            See: http://thejit.org/docs/ for more options
        """
        proof = utils.get_full_proof(obj)
        proof[0]['data'].update({
            '$color': '#dd514c',
            '$dim': 5
        })
        return proof

    # Finding methods
    def find_proofs(self, implication):
        """ Returns spaces for which the implication can prove new traits
        """
        return utils.find_proofs(implication)

    def examples(self, implication):
        """ Returns spaces for which the implication is known to hold
        """
        return utils.examples(implication)

    def counterexamples(self, implication):
        """ Returns examples for which the implication does not hold.
            This should return [] for any saved Implication
        """
        return utils.counterexamples(implication)

    def spaces_matching_formula(self, formula):
        """ Finds spaces for which the formula holds """
        return utils.spaces_matching_formula(formula=formula)

    def implied_traits(self, obj):
        """ Find all objects that this Prover added to the database using the
            given object as an assumption.
        """
        # The natural way of doing this is broken because of a Django bug that
        # forced me to remove the reverse generic relation
        # TODO: fix http://code.djangoproject.com/ticket/12728
        from brubeck.models import Trait

        ident = '%s%s,' % (obj.__class__.__name__[0].lower(), obj.id)
        t_ids = [s.object_id for s in Snippet.objects.filter(
            revision__text__contains=ident, proof_agent=self.agent)]
        return Trait.objects.filter(id__in=t_ids)

    def _all_added_snippets(self):
        """ Finds all snippets that were added by this Prover
        """
        return Snippet.objects.filter(proof_agent=self.agent)

    # Creation methods
    def _force_match(self, formula, space, proof_steps):
        """ Forces the given Space to match the formula by adding Traits as
            needed.

            `proof_steps` are added to the start of the automatically generated
            proof, and should consist of a list of Traits and Implications.
        """
        if formula.is_atom():
            ts = space.trait_set.filter(property__id=formula.property)
            if ts.exists():
                if unicode(ts.get().value.id) == formula.value:
                    pass  # Should we warn that the space already matches?
                else:
                    raise AssertionError(u'%s cannot match %s' %
                                         (formula, space))
            else:
                self._add_proof(space=space, property_id=formula.property,
                    value_id=formula.value, proof_steps=proof_steps)
        elif formula.operator == Formula.AND:
            for sf in formula.sub:
                self._force_match(sf, space, proof_steps)
        else:  # formula.operator == Formula.OR
            # Verify that the negation of all but one subformula matches
            unknown_sf = None
            extra_steps = []
            for sf in formula.sub:
                try:
                    extra_steps += self.verify_match(sf.negate(), space)
                except AssertionError:
                    # This subformula has an unknown value
                    if unknown_sf:  # We have multiple unknown subformulae
                        raise AssertionError(u'Tried to force an OR statement '
                            u'multiple unknowns (%s)' % formula)
                    unknown_sf = sf
            if unknown_sf:  # The single (formerly) unknown must be true
                self._force_match(unknown_sf, space, proof_steps + extra_steps)
            else:
                raise AssertionError(u'Tried to force OR statement with '
                                     u'no unknowns (%s)' % formula)

    def _add_proof(self, space, property_id, value_id, proof_steps):
        """ A proof is simply a series of Traits or Implications formatted as:
            t<id>,t<id>,i<id>,t<id>,t<id>,...
        """
        from brubeck.models import Trait

        proof_string = ''
        for s in proof_steps:
            if isinstance(s, Trait):
                proof_string += 't%s,' % s.id
            else:  # s is an Implication
                proof_string += 'i%s,' % s.id
        t = Trait(space=space)
        t.property_id, t.value_id = property_id, value_id
        t.save()
        self._add_snippet(object=t, text=proof_string)
        logger.debug('Added trait "%s" with proof "%s"' % (t, proof_string))

    def _add_snippet(self, object, text):
        """ Adds a new snippet for the given `object`, setting `text` as its
            initial revision. Also sets proof_agent and user metadata.

            If overridden, this method *must* set proof_agent on newly created
            Snippets.
        """
        # TODO: between the gfks and revisions and objects needing to be saved
        #       before saving things that depend on them, saving a newly
        #       created object takes a comparatively large number of queries
        #       It'd be nice if we could improve the efficiency there.

        # The object must be saved before creating a snippet pointing to it
        if not object.id:
            object.save()
        snippet = Snippet(object=object, proof_agent=self.agent)
        snippet.save()
        # The _or_create bit helps for unit testing
        brubeck, _ = User.objects.get_or_create(username='brubeck')
        snippet.add_revision(text=text, user=brubeck)

    def apply(self, implication, space):
        # Try applying the forward directions
        try:
            proof_steps = self.verify_match(
                formula=implication.antecedent, space=space)
            proof_steps.append(implication)
            self._force_match(formula=implication.consequent, space=space,
                proof_steps=proof_steps)
        except AssertionError as e:
            pass
        # And the contrapositive
        try:
            proof_steps = self.verify_match(
                formula=implication.consequent.negate(), space=space)
            proof_steps.append(implication)
            self._force_match(formula=implication.antecedent.negate(),
                space=space, proof_steps=proof_steps)
        except AssertionError as e:
            pass

    def _add_proofs(self):
        """ Searches the entire database for new proofs """
        # TODO: this is (currently) only used post-delete. Is there any way to
        #       make it more efficient? Is it really needed?
        return utils._add_proofs(self)

    # Verification methods
    def verify_match(self, formula, space):
        """ Checks a space against a formula, raising an AssertionError if the
            space does not match and returning the list of Traits showing the
            match if it does.
        """
        return utils.verify_match(formula=formula, space=space)

    # Documentation methods


Prover = BaseProver(agent=BRUBECK_AGENT)
